# Broken Rotor Bar Fault Detection in AC Induction Motor: A Deep Dive
The original documentation for this project is the MATLAB Help Center, where the application of the Diagnostic Feature Designer app within the software is showcased by solving the broken rotor fault classification problem. In this repository, I shed light on the details of the project by delving into every aspect as I understand it. By playing with the code and running it on my local machine, I explain the logic and technologies used to detect fau lts associated with an AC induction motor via vibration analysis and machine learning. The sources I used are ([Identifying Motor Faults using Machine Learning for Predictive Maintenance](https://www.youtube.com/watch?v=JwZ5ffZk-fM)) and ([Broken Rotor Fault Detection in AC Induction Motors Using Vibration and Electrical Signals](https://www.mathworks.com/help/predmaint/ug/broken-rotor-fault-detection-in-ac-induction-motors-using-vibration-and-electrical-signals.html)).

Let’s break down the project:

# Data
The data required for this project was generated by an experiment conducted in the Laboratory of Intelligent Automation of Processes and Systems & Laboratory of Intelligent Control of Electrical Machines, School of Engineering of São Carlos at the University of São Paulo (USP), Brazil.

While I invite the reader to view a more detailed description of the experimental setup and machine specifications (here), I will only discuss the important highlights. The experiment consists of a 3-phase induction motor coupled with a DC machine that is used to generate several torque loads. The torque loads considered total 8, ranging from 12.5% to 100% of full load. Failures in the rotor bars were simulated by physically drilling the rotor, with a total of 4 rotors being tested.

From the sampled data of the experiment, a total of 12 data variables were collected and fed into the ensemble datastore: "Va", "Vb", "Vc", "Ia", "Ib", "Ic", "Vib_acpi", "Vib_carc", "Vib_acpe", "Vib_axial", "Vib_base", and "Trigger". In addition to these, condition variables were also defined: "health" and "load". While the former refers to the number of broken rotor bars (0–4), the latter refers to the load level applied by the DC generator.

Aside from the 12 variables directly obtained from the experiment, three additional synthetic variables (Vib_acpi_env, Ia_env_ps, Ia_env_ps) were generated using the functions getSignal.m and readMemberData.m.

The details of how the raw experimental results are converted into members of the datastore and how the synthetic variables are generated are explained in the "app.mlx" live script. Furthermore, visuals for the respective variables are provided for easier understanding.

# Feature Generation and Classification of Faults
Once the variables of the ensemble datastore are incorporated into the ensemble variable, the diagnosticFeatureDesign app is run and fed the initialized ensemble datastore.

Although the "Auto Features" option is available in the MATLAB version of the documentation, the version on my local machine doesn't support this feature. So, I am limited to using the Time Domain Feature Generator and the Custom Spectral Feature Generator for Vib_acpi_env and Ia_env_ps, respectively.

During the spectral feature generation, certain parameters were clearly defined: Harmonics (6), Sidebands (0,1), Fault Width (10 Hz), and Sideband Separation (30 Hz). Based on these parameters, features were generated and placed in the features table for ranking (based on one-way ANOVA).

Then, the ranked features were exported to the Classification Learner app to build tree models. Note that only the top 10 ranked features were exported to the learner app. Inside the Classification Learner window, a new session is started to access the models within this MATLAB feature.

Apart from running a single model at a time, there is a "Quick Train" option whereby one can select the best-performing classification model. Accordingly, KNN was found to result in an accuracy of 92.5%, as can be seen in the pictures provided.

# Modification to original documentation
Visualization for clearer examination of the data and its modification by @readfcn

Extracted electrical and mechanical signals
'''javascript
sampleData = load(filename);
fields = fieldnames(sampleData);
for i = 1:numel(fields) 
signal = sampleData.(fields{i});
if (isnumeric(signal)) & (numel(signal) > 1)
time = 0:size(signal)-1;
switch fields{i}           
    case {'Va', 'Vb', 'Vc', 'Ia', 'Ib', 'Ic'}
      % Electrical signals
      time = time/sampleData.(fields{1});
      des_time = find((time >= 10.0) & (time <= 11.0));
      figure;
      subplot(2,1,1)
      plot(time(des_time), signal(des_time))
      xlabel("time(s)")
      ylabel(fields{i})
      title(fields{i}+" 10s - 11s")
'''
              subplot(2,1,2)
              plot(time, signal)
              xlabel("time(s)")
              ylabel(fields{i})
              title(fields{i}+" from start to steady state")

            case {'Vib_acpi', 'Vib_carc', 'Vib_acpe', 'Vib_axial', 'Vib_base', 'Trigger'}
              % Vibration signals
              time = time/sampleData.(fields{2});
              des_time = find((time >= 10.0) & (time <= 11.0));
              
              figure;
              subplot(2,1,1)
              plot(time(des_time), signal(des_time))
              xlabel("time(s)")
              ylabel(fields{i})
              title(fields{i}+" 10s - 11s")
              
              subplot(2,1,2)
              plot(time, signal)
              xlabel("time(s)")
              ylabel(fields{i})
              title(fields{i}+" from start to steady state")
        end
    end 
end

Synthetic signals
Three synthetic signals are generated [Vib_acpi_env, Ia_env, Ia_env_ps]
Here, we will go through the generation process using just one member data
Ia_env - Envelop of filtered phase "a" current signal

Ia_ = sampleData.Ia;
n = size(Ia_, 1);
ti = (0:n-1)' / sampleData.Fs_elec; %create a vertical array of time for the signal
I = find((ti >= 10.0) & (ti <= 11.0));% 1.0 sec of data from 10s to 11s
%create a table for the selected data
TT = timetable(Ia_(I), 'VariableNames', "Data", 'RowTimes', seconds(ti(I)));

% Envelope of band-pass filtered signal
y = bandpass(TT.Data, [900 1300], sampleData.Fs_elec);%filter signal to pass those having a frequency from 900 to 1300 Hz
yUpper = envelope(y);%use the envelop function to pinpoint the high and lows of the signal

%the following figure helps visualize both Ia(1second) and its envelop

figure();
subplot(3,1,1)
plot(ti(I(end-1000:end,1)), y(end-1000:end,1))
xlabel("time from 10.98s - 11s")
title("filtered Ia(900-1300 Hz)")

subplot(3,1,2)
plot(ti(I(end-1000:end,1)), yUpper(end-1000:end,1))
xlabel("time from 10.98s - 11s")
title("Envelope(Yupper) of filtered signal(Ia)", 'FontAngle','italic')

[yUpper_env, yLower_env] = envelope(y);
subplot(3,1,3)
plot(ti(I(end-1000:end,1)), yUpper_env(end-1000:end,1))
hold on
plot(ti(I(end-1000:end,1)), yLower_env(end-1000:end,1))
hold on
plot(ti(I(end-1000:end,1)), y(end-1000:end,1))
hold off

xlabel("time from 10.98s - 11s")
ylabel("Envelope(Ia-filtered)", 'FontAngle','italic')

Ia_env_ps - Envelop of the spectrum of band-pass filtered Ia


%find the envelop of the spectrum of band-pass filtered Ia
[ES,F] = envspectrum(TT, 'Method', 'hilbert', 'Band', [900 1300]);

figure;
plot(F, ES)
xlabel("frequency in Hz")
ylabel("peak amplitude")







  
