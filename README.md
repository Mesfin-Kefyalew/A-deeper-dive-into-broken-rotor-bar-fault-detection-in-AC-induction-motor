# Broken-rotor-bar-fault-detection-in-AC-induction-motor: A deep dive

The original documentation for this project is the matlab help center where the application of diagnostic feature designer app within the software has been showcased. In this repository I will shed light on the details of the project by delving its every aspect as I understand it, playing with code and running it on my local machine , I explain the logic and technologies that was used to detect the fault associated with an AC induction motor via vibration analysis and machine learning. Let's break down the project: 

# Data
The data required for this project was generated by an experiment conducted in the laboratory of intelligent automation of processes and systems & laboratory of Intelligent Control of Electrical Machines, School of Engineering of São Carlos of the University of São Paulo (USP), Brazil.

While I invite the view to read a more detailed description of the experimental setup and machine specs ([here](https://ieee-dataport.org/open-access/experimental-database-detecting-and-diagnosing-rotor-broken-bar-three-phase-induction)). here i will only discuss the important highlights. The experiment consists of a 3-phase induction motor coupled with a dc machine that is used to generate several load torque. The torque loads considered are a total of 8 from 12.5% to 100% of the full load[]. Failure on the rotor bars was simulated by physically drilling the rotor with a total of 4 rotors being tested.

From the sampled data of the experiment, a total of 12 data variables are collected and fed into the ensamble datastore: "Va"; "Vb"; "Vc"; "Ia"; "Ib"; "Ic"; "Vib_acpi"; "Vib_carc"; "Vib_acpe"; "Vib_axial"; "Vib_base"; "Trigger". Apart from these, condition variables are also defined: "health" and "load". While the first refers to the number of broken rotor bars(0-4), the later refers to the load level applied by the dc generator. Aside from the 12 variables directly obtained from the experiment additional three variables(Vib_acpi_env, Ia_env_ps, Ia_env_ps) are generated using the functions: getSignal.m, readMemberData.m.

The details of how the raw experimental results are converted into members of the datastore are and how the synthetic variables are generated are explained in the "app.mlx" live script. Furthermore, visuals for the respective variables are depicted for easier understanding.

Once the variables of the ensamble datastore are incorporated into the ensamble variable, the diagnosticFeatureDesign is run and fed the initialized ensamble datastore. 


  
